/*
 * ad9361_Class.cpp
 *
 *  Created on: Jan 5, 2021
 *      Author: GMateusDP
 */

#include "AD9361_Class.h"
#include "alt_types.h"
#include "system.h"
#include "altera_avalon_spi.h"
#include "altera_avalon_spi_regs.h"
#include "altera_avalon_pio_regs.h"
#include "ad9361_api.h"
#include "BLADERFCOMMONCLASS.h"

#include "stdlib.h"




AD9361_Class  *ptr_adi_class;
//namespace ad9361_driver {
static  ad9361_rf_phy local_ad9361_phy;

AD9361_Class::AD9361_Class() {
	// TODO Auto-generated constructor stub
	ptr_adi_class=this;
	ad9361_phy=&local_ad9361_phy;
	isOK=false;
	herz_tolerance=100;
	set_rx_pll_frequency=0;
}

AD9361_Class::~AD9361_Class() {
	// TODO Auto-generated destructor stub
}

bool AD9361_Class::Init(void){
	ptr_adi_class=this;
	ad9361_phy=&local_ad9361_phy;
	int32_result=ad9361_init(&ad9361_phy, &bladerf2_rfic_init_params,ptr_adi_class);
	isOK= int32_result==0;
	return isOK;
}
bool AD9361_Class::Init(ad9361_rf_phy *phy,void *userdata){
	ptr_adi_class=this;
	ad9361_phy=&local_ad9361_phy;

	int32_result=ad9361_init(&ad9361_phy, &bladerf2_rfic_init_params,userdata);
	phy=ad9361_phy;
	isOK= int32_result==0;
	return isOK;
}

uint32_t AD9361_Class::Get_rf_phy(void){
	return (uint32_t)ad9361_phy;
}
uint32_t AD9361_Class::Set_RX_PLL_Frequency(uint64_t fv){
	set_rx_pll_frequency=fv;
	return ad9361_set_rx_lo_freq(ad9361_phy,fv);
}
uint32_t AD9361_Class::Set_TX_PLL_Frequency(uint64_t fv){
	set_rx_pll_frequency=fv;
	return ad9361_set_tx_lo_freq(ad9361_phy,fv);
}
uint64_t AD9361_Class::Get_RX_PLL_Frequency(void){
	ad9361_get_rx_lo_freq(ad9361_phy,&current_rx_pll_frequency);
	return current_rx_pll_frequency;
}
uint32_t AD9361_Class::Set_TX_Tone_Frequency(uint64_t fv){
	bist_tone_frequency=clk_get_rate(ad9361_phy,ad9361_phy->ref_clk_scale[TX_SAMP_CLK])*(TONE_FREQUENCY+1)/32;
	Set_TX_PLL_Frequency(fv-bist_tone_frequency);

	return ad9361_bist_tone(ad9361_phy,BIST_INJ_TX,TONE_FREQUENCY,TONE_LEVEL_dB,TONE_MASK);
}

bool AD9361_Class::IsLocked(void){
	return herz_tolerance>abs((long)(set_rx_pll_frequency-Get_RX_PLL_Frequency()));
}
uint32_t AD9361_Class::get_ensm_mode(void){
	ad9361_get_en_state_machine_mode(ad9361_phy,&ensm_mode);
	return ensm_mode;
}
bool AD9361_Class::set_ensm_mode(uint32_t em){
	return ad9361_set_en_state_machine_mode(ad9361_phy,em);

}


uint64_t AD9361_Class::spi_read(uint16_t addr)
{
    alt_u8 addr8[2];
    alt_u8 data8[8];
    alt_u8 bytes;
    uint8_t i;
    uint64_t rv;

    // The alt_avalon_spi_command expects parameters to be arrays of bytes

    // Convert the uint16_t address into array of 2 uint8_t
    addr8[0] = (addr >> 8);
    addr8[1] = (addr & 0xff);

    // Calculate number of data bytes in this command
    bytes = (((addr >> 12) & 0x7) + 1);

    // Send down the command, read the response into data8
    alt_avalon_spi_command(AD9361_BASE, 0, 2, &addr8[0], bytes, &data8[0], 0);

    // Build the uint64_t return value
    rv = UINT64_C(0x0);
    for (i = 0; i < 8; i++) {
        rv |= (((uint64_t)data8[i]) << 8 * (7 - i));
    }

    return rv;
}



void AD9361_Class::spi_write(uint16_t addr, uint64_t data)
{
    alt_u8 data8[10];
    alt_u8 bytes;
    uint8_t i;

    // The alt_avalon_spi_command expects parameters to be arrays of bytes

    // Convert the uint16_t address into array of 2 uint8_t
    data8[0] = (addr >> 8) | 0x80; /* Make sure write bit is set */
    data8[1] = (addr & 0xff);

    // Convert the uint64_t data into an array of 8 uint8_t
    for (i = 0; i < 8; i++) {
        data8[i + 2] = (data >> 8 * (7 - i)) & 0xff;
    }

    // Calculate number of command and data bytes in this command
    bytes = (((addr >> 12) & 0x7) + 1) + 2;

    // Send down the command and the data
    alt_avalon_spi_command(AD9361_BASE, 0, bytes, &data8[0], 0, 0, 0);
}

uint32_t AD9361_Class::axi_read(uint16_t addr)
{
    uint32_t data = 0;
#ifdef SPIN_SENSOR_RECEIVER_0_BASE  // Temporary hack for bladeRF1 compat
    data = IORD_32DIRECT(SPIN_SENSOR_RECEIVER_0_BASE, addr);
#endif
    return data;
}

void AD9361_Class::axi_write(uint16_t addr, uint32_t data)
{
#ifdef SPIN_SENSOR_RECEIVER_0_BASE  // Temporary hack for bladeRF1 compat
    IOWR_32DIRECT(SPIN_SENSOR_RECEIVER_0_BASE, addr, data);
#endif
}

void AD9361_Class::fastlock_save(bool is_tx, uint8_t rffe_profile, uint16_t nios_profile)
{
    uint16_t fl_prog_addr_reg;
    uint16_t fl_prog_rddata_reg;
    uint16_t addr;
    uint64_t data;
    uint32_t i;
    fastlock_profile *fastlocks;

    if (is_tx) {
        fl_prog_addr_reg   = 0x29c;
        fl_prog_rddata_reg = 0x29e;
        fastlocks          = fastlocks_tx;
    } else {
        fl_prog_addr_reg   = 0x25c;
        fl_prog_rddata_reg = 0x25e;
        fastlocks          = fastlocks_rx;
    }

    /* Read out the profile data and save to Nios memory */
    for (i = 0; i < 16; i++) {
        addr = (0x1 << 15) | (0x0 << 12) | (fl_prog_addr_reg & 0x3ff);
        data = (uint64_t)(((rffe_profile & 0x7) << 4) | (i & 0xf)) << 8 * 7;
        spi_write(addr, data);

        addr = (0x0 << 15) | (0x0 << 12) | (fl_prog_rddata_reg & 0x3ff);
        fastlocks[nios_profile].profile_data[i] = spi_read(addr) >> 56;
    }

    /* Kick out any other profile stored in the Nios that was in this slot */
    for (i = 0; i < NUM_BBP_FASTLOCK_PROFILES; i++) {
        if ((fastlocks[i].profile_num == rffe_profile) &&
            (fastlocks[i].state == FASTLOCK_STATE_BBP_RFFE)) {
            fastlocks[i].state = FASTLOCK_STATE_BBP;
        }
    }

    /* Update profile state */
    fastlocks[nios_profile].state = FASTLOCK_STATE_BBP_RFFE;
}

void AD9361_Class::fastlock_load(bladerf_module m, fastlock_profile *p)
{
    static const uint8_t fl_prog_write = 1 << 1;
    static const uint8_t fl_prog_clken = 1 << 0;
    static const uint8_t fl_prog_bytes = 16;
    uint16_t fl_prog_data_reg;
    uint16_t fl_prog_ctrl_reg;
    uint32_t i;
    uint16_t addr;
    uint64_t data;
    fastlock_profile *fastlocks;

    if (BLADERF_CHANNEL_IS_TX(m)) {
        fl_prog_data_reg = 0x29d;
        fl_prog_ctrl_reg = 0x29f;
        fastlocks        = fastlocks_tx;
    } else {
        fl_prog_data_reg = 0x25d;
        fl_prog_ctrl_reg = 0x25f;
        fastlocks        = fastlocks_rx;
    }

    if ((p->state == FASTLOCK_STATE_RFFE) ||
        (p->state == FASTLOCK_STATE_BBP_RFFE)) {
        /* Already loaded! */
        return;
    } else {
        /* Kick out any other loaded profile that's in this slot */
        for (i = 0; i < NUM_BBP_FASTLOCK_PROFILES; i++) {
            if ((fastlocks[i].profile_num == p->profile_num) &&
                (fastlocks[i].state == FASTLOCK_STATE_BBP_RFFE)) {
                fastlocks[i].state = FASTLOCK_STATE_BBP;
            }
        }

        /* Write 2 bytes to fast lock program data register */
        addr = (0x1 << 15) | (0x1 << 12) | (fl_prog_data_reg & 0x3ff);
        data = (uint64_t)(p->profile_data[0]) << 8 * 7;
        data |= (uint64_t)(((p->profile_num & 0x7) << 4) | (i & 0xf)) << 8 * 6;
        spi_write(addr, data);

        for (i = 1; i < fl_prog_bytes; i++) {
            /* Write 4 bytes to fast lock program control register */
            addr = (0x1 << 15) | (0x3 << 12) | (fl_prog_ctrl_reg & 0x3ff);
            data = (uint64_t)(fl_prog_write | fl_prog_clken) << 8 * 7;
            data |= UINT64_C(0x0) << 8 * 6;
            data |= (uint64_t)(p->profile_data[i]) << 8 * 5;
            data |= ((uint64_t)(((p->profile_num & 0x7) << 4) | (i & 0xf))
                     << 8 * 4);
            spi_write(addr, data);
        }

        /* Write 1 byte to fast lock program control register */
        addr = (0x1 << 15) | (0x0 << 12) | (fl_prog_ctrl_reg & 0x3ff);
        data = (uint64_t)(fl_prog_write | fl_prog_clken) << 8 * 7;
        spi_write(addr, data);

        /* Write 1 byte to fast lock program control register */
        addr = (0x1 << 15) | (0x0 << 12) | (fl_prog_ctrl_reg & 0x3ff);
        spi_write(addr, 0);

        /* Update profile state */
        p->state = FASTLOCK_STATE_BBP_RFFE;
    }
}

void AD9361_Class::fastlock_recall(bladerf_module m, fastlock_profile *p)
{
    uint16_t fl_setup_reg = BLADERF_CHANNEL_IS_TX(m) ? 0x29a : 0x25a;
    uint16_t addr;
    uint64_t data = 0;

    addr = (0x1 << 15) | (0x0 << 12) | (fl_setup_reg & 0x3ff);
    data = (uint64_t)(((p->profile_num & 0x7) << 5) | (0x1)) << 8 * 7;

    spi_write(addr, data);
}

void AD9361_Class::rfport_select(fastlock_profile *p)
{
    static const uint16_t input_sel_reg = 0x4;
    static const uint8_t rx_port_mask   = 0x3f;
    static const uint8_t tx_port_mask   = 0x40;
    uint16_t addr;
    uint64_t data;

    /* Get current port selection */
    addr = (0x0 << 15) | (0x0 << 12) | (input_sel_reg & 0x3ff);
    data = spi_read(addr) >> 56;

    if (p->port >> 7) {
        /* RX bit is set, only modify RX port selection */
        data = (data & ~rx_port_mask) | (p->port & rx_port_mask);
    } else {
        /* RX bit is clear, only modify TX port selection */
        data = (data & ~tx_port_mask) | (p->port & tx_port_mask);
    }

    /* Write the new port selection to AD9361 */
    addr = (0x1 << 15) | (0x0 << 12) | (input_sel_reg & 0x3ff);
    data = data << 56;
    spi_write(addr, data);
}








//} /* namespace ad9361_driver */

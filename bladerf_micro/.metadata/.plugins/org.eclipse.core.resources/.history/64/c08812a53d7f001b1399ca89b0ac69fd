/*
 * SENSORREADERCLASS.h
 *
 *  Created on: Jan 6, 2021
 *      Author: GMateusDP
 */

#ifndef SENSORREADERCLASS_H_
#define SENSORREADERCLASS_H_
#include "AD9361_Class.h"
#include "RFFEClass.h"
#include "BLADERFCOMMONCLASS.h"
#include "libbladeRF.h"
//#include "devices_rfic.h"
typedef uint8_t command_bitmask;

#define RFIC_CMD_INIT_REQD 1   /**< Command requires initialized state */
#define RFIC_CMD_CHAN_SYSTEM 2 /**< Command valid for wildcard channels */
#define RFIC_CMD_CHAN_TX 4     /**< Command valid for TX channels */
#define RFIC_CMD_CHAN_RX 8     /**< Command valid for RX channels */

#define COMMAND_QUEUE_MAX 16
#define COMMAND_QUEUE_FULL 0xff
#define COMMAND_QUEUE_EMPTY 0xfe
#define MAX_RX_BANDWIDTH 56*1000*1000
#define MAX_SAMPLINGRATE 61440*1000

/******************************************************************************/
/* Structures */
/******************************************************************************/

/******************************************************************************/
/* Helpers */
/******************************************************************************/

/**
 * @brief      Translate a bladerf_direction and channel number to a
 *             bladerf_channel
 *
 * @param      _dir  Direction
 * @param      _idx  Channel number
 *
 * @return     BLADERF_CHANNEL_TX(_idx) or BLADERF_CHANNEL_RX(_idx)
 */
#define CHANNEL_IDX(_dir, _idx) \
    (BLADERF_TX == _dir) ? BLADERF_CHANNEL_TX(_idx) : BLADERF_CHANNEL_RX(_idx)

/**
 * @brief      Iterate over all bladerf_directions
 *
 * @param      _dir  Direction
 */
#define FOR_EACH_DIRECTION(_dir) \
    for (_dir = BLADERF_RX; _dir <= BLADERF_TX; ++_dir)

/**
 * @brief      Iterate over all channels in a given direction
 *
 * @param      _dir      Direction
 * @param      _count    Number of channels
 * @param[out] _index    Index variable (size_t)
 * @param[out] _channel  Channel variable (bladerf_channel)
 *
 * @return     { description_of_the_return_value }
 */
#define FOR_EACH_CHANNEL(_dir, _count, _index, _channel)                    \
    for (_index = 0, _channel = CHANNEL_IDX(_dir, _index); _index < _count; \
         ++_index, _channel   = CHANNEL_IDX(_dir, _index))

/* Packet decoding debugging output */
static char const RFIC_DBG_FMT[] = "%s: cmd=%s ch=%s state=%s [%x]=%x(-%x)\n";
#define RFIC_DBG(prefix, cmd, ch, state, addr, data) \
    DBG(RFIC_DBG_FMT, prefix, cmd, ch, state, addr, data, -data)

/* Error message output */
static char const RFIC_ERR_FMT[] = "%s: error: %s returned %x (-%x)\n";
#define RFIC_ERR(thing, retval) \
    DBG(RFIC_ERR_FMT, __FUNCTION__, thing, retval, -retval)

/**
 * @brief      Error-catching wrapper
 *
 * @param      _fn   The function to wrap
 *
 * @return     false on error (_fn() < 0), continues otherwise
 */
#define CHECK_BOOL(_fn)         \
    do {                        \
        int _s = _fn;           \
        if (_s < 0) {           \
            RFIC_ERR(#_fn, _s); \
            return false;       \
        }                       \
    } while (0)

#define RFIC_SYSTEM_CHANNEL 0xF
/* State of items in the command queue */
enum rfic_entry_state {
    ENTRY_STATE_INVALID = 0, /* Marks entry invalid and not in use */
    ENTRY_STATE_NEW,         /* We have a new command request to satisfy */
    ENTRY_STATE_RUNNING,     /* Currently executing a job */
    ENTRY_STATE_COMPLETE,    /* The job is complete */
};

/* An entry in the command queue */
struct rfic_queue_entry {
    volatile enum rfic_entry_state state; /* State of this queue entry */
    uint8_t rv;                           /* Return value */
    uint8_t ch;                           /* Channel */
    uint8_t cmd;                          /* Command */
    uint64_t value;                       /* Value to pass to command */
};

/* A queue itself */
struct rfic_queue {
    uint8_t count;   /* Total number of items in the queue */
    uint8_t ins_idx; /* Insertion index */
    uint8_t rem_idx; /* Removal index */
    uint8_t last_rv; /* Returned value from executing last command */

    struct rfic_queue_entry entries[COMMAND_QUEUE_MAX];
};




/**
 * RFIC command handler state structure
 */
struct rfic_state {
    /* Initialization state */
    bladerf_rfic_init_state init_state;

    /* AD9361 state structure */
    struct ad9361_rf_phy *phy;

    /* Queue for handling long-running write operations */
    struct rfic_queue write_queue;

    /* RX and TX FIR filter memory */
    bladerf_rfic_rxfir rxfir;
    bladerf_rfic_txfir txfir;

    /* Frequency retrieval is invalid due to fastlock shenanigans */
    bool frequency_invalid[NUM_MODULES];

    /* TX mute state at standby */
    bool tx_mute_state[2];
};

class SENSOR_READER_CLASS : public AD9361_Class, public RFFE_Class, private BLADERF_COMMON_CLASS
{
public:
	bool isOk;
	 uint64_t current_frequency;
private:
	AD9361_Class  *adi;
	RFFE_Class  *rffe;
	ad9361_rf_phy *phy;
	uint64_t init_freq,init_samprate;
	  AD9361_InitParam *init_param;
	  AD9361_RXFIRConfig bladerf2_rfic_rx_fir_config;
	  AD9361_TXFIRConfig bladerf2_rfic_tx_fir_config;
	   AD9361_RXFIRConfig bladerf2_rfic_rx_fir_config_dec2;
	   AD9361_TXFIRConfig bladerf2_rfic_tx_fir_config_int2;
	   AD9361_RXFIRConfig bladerf2_rfic_rx_fir_config_dec4;
	  AD9361_TXFIRConfig bladerf2_rfic_tx_fir_config_int4;
	  rfic_state *state;
	  bladerf_channel ch;
	  uint32_t	enabled;
	  uint64_t required_frequency,tx_frequency;
	  uint8_t channel;
	  uint32_t	herz_tolerance;
	  bool islocked;
	  uint32_t ensm_mode;


public:
	SENSOR_READER_CLASS();
	virtual ~SENSOR_READER_CLASS();
	bool Init(void);
	void _reset_rfic(bool state);
	bool set_frequency(uint64_t);
	bool is_locked(void);
	bool enable_port(bool en);
	uint32_t force_ENSM_RX_mode(void);
	bool Set_TX_Tone_Frequency( bladerf_channel channel,uint64_t frequency);

private:
	bool configure_rx_path(void);

	bool _rfic_cmd_wr_enable(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_enable(struct rfic_state *, bladerf_channel, uint32_t *);


	bool _rfic_cmd_wr_samplerate(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_samplerate(struct rfic_state *, bladerf_channel, uint32_t *);

	bool _rfic_cmd_wr_frequency(struct rfic_state *, bladerf_channel, uint64_t);

	bool _rfic_cmd_rd_frequency(struct rfic_state *, bladerf_channel, uint64_t *);

	bool _rfic_cmd_wr_bandwidth(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_bandwidth(struct rfic_state *, bladerf_channel, uint32_t *);

	bool _rfic_cmd_wr_gainmode(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_gainmode(struct rfic_state *, bladerf_channel, uint32_t *);

	bool _rfic_cmd_wr_gain(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_gain(struct rfic_state *, bladerf_channel, uint32_t *);

	bool _rfic_cmd_rd_rssi(struct rfic_state *, bladerf_channel, uint64_t *);

	bool _rfic_cmd_wr_filter(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_filter(struct rfic_state *, bladerf_channel, uint32_t *);

	bool _rfic_cmd_wr_txmute(struct rfic_state *, bladerf_channel, uint32_t);

	bool _rfic_cmd_rd_txmute(struct rfic_state *, bladerf_channel, uint32_t *);

	bool _rfic_cmd_wr_fastlock(struct rfic_state *, bladerf_channel, uint32_t);
	/**
	 * @brief       Get the transmit mute state
	 *
	 * @param       phy     RFIC handle
	 * @param[in]   ch      Channel
	 * @param[out]  state   Mute state: true for muted, false for unmuted
	 *
	 * @return      0 on success, value from \ref RETCODES list on failure
	 */
	int txmute_get(struct ad9361_rf_phy *phy, bladerf_channel ch, bool *state);

	/**
	 * @brief       Sets the transmit mute.
	 *
	 * If muted, the TX attenuation will be set to maximum to reduce leakage
	 * as much as possible.
	 *
	 * When unmuted, TX attenuation will be restored to its previous value.
	 *
	 * @param       phy     RFIC handle
	 * @param[in]   ch      Channel
	 * @param[in]   state   Mute state: true for muted, false for unmuted
	 *
	 * @return      0 on success, value from \ref RETCODES list on failure
	 */
	int txmute_set(struct ad9361_rf_phy *phy, bladerf_channel ch, bool state);

	/**
	 * @brief       Set AD9361 RFIC RF port
	 *
	 * @param       phy     RFIC handle
	 * @param[in]   ch      Channel
	 * @param[in]   enabled True if the channel is enabled, false otherwise
	 * @param[in]   freq    Frequency
	 *
	 * @return      0 on success, value from \ref RETCODES list on failure
	 */
	int set_ad9361_port_by_freq(struct ad9361_rf_phy *phy,
	                            bladerf_channel ch,
	                            bool enabled,
	                            bladerf_frequency freq);
	/**
	 * @brief       Retrieve current value in TX attenuation cache.
	 *
	 * @param       phy     RFIC handle
	 * @param[in]   ch      Channel
	 *
	 * @return      Cached attenuation value
	 */
	uint32_t txmute_get_cached(struct ad9361_rf_phy *phy, bladerf_channel ch);

	/**
	 * @brief       Save a new value to the TX attenuation cache.
	 *
	 * @param       phy     RFIC handle
	 * @param[in]   ch      Channel
	 * @param[in]   atten   Attenuation
	 *
	 * @return      0 on success, value from \ref RETCODES list on failure
	 */
	int txmute_set_cached(struct ad9361_rf_phy *phy,
	                      bladerf_channel ch,
	                      uint32_t atten);
};

#endif /* SENSORREADERCLASS_H_ */

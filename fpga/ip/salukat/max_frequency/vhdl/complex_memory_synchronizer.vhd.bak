library ieee ;
    use ieee.std_logic_1164.all ;
	 


entity complex_memory_synchronizer is
  generic (
    VALID_LEVEL :       std_logic   := '0';
    DATA_WIDTH      : positive  := 24

  ) ;
  port (
    valid       :   in  std_logic ;
    clock       :   in  std_logic ;
    async_re       :  std_logic_vector(DATA_WIDTH/2-1 downto 0) ;
    async_im       :   std_logic_vector(DATA_WIDTH/2-1 downto 0) ;
    sync        :   out std_logic := (others=>RESET_LEVEL)
  ) ;
end entity ;

architecture arch of complex_memory_synchronizer is

  --  attribute ALTERA_ATTRIBUTE  : string;
  --  attribute PRESERVE          : boolean;

    signal reg0, reg1   : std_logic_vector(DATA_WIDTH-1 downto 0) ;

  --  attribute ALTERA_ATTRIBUTE of arch  : architecture is "-name SDC_STATEMENT ""set_false_path -to [get_registers {*synchronizer:*|reg0}] """;
 --   attribute ALTERA_ATTRIBUTE of reg0  : signal is "-name SYNCHRONIZER_IDENTIFICATION ""FORCED IF ASYNCHRONOUS""";
  --  attribute ALTERA_ATTRIBUTE of reg1  : signal is "-name SYNCHRONIZER_IDENTIFICATION ""FORCED IF ASYNCHRONOUS""";
  --  attribute PRESERVE of reg0          : signal is TRUE;
  --  attribute PRESERVE of reg1          : signal is TRUE;
   -- attribute PRESERVE of sync          : signal is TRUE;

begin

    synchronize : process( clock, reset )
    begin
        if( valid = '0' ) then
            sync <= (others=>RESET_LEVEL)
            reg0 <= (others=>RESET_LEVEL) ;
            reg1 <= (others=>RESET_LEVEL) ;
        elsif( rising_edge( clock ) ) then
            sync<=reg1;
            reg1 <= reg0 ;
            reg0( DATA_WIDTH-1 downto  DATA_WIDTH/2) <=std_logic_vector(async_re);
            reg0( DATA_WIDTH/2-1 downto  0) <= std_logic_vector(async_im);
        end if ;
    end process ;

end architecture ;

